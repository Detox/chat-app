// Generated by LiveScript 1.5.0
/**
 * @package Detox chat app
 * @author  Nazar Mokrynskyi <nazar@mokrynskyi.com>
 * @license 0BSD
 */
(function(){
  var defined_modules, current_module, wait_for, get_defined_module, load_dependencies, add_wait_for;
  if (typeof requirejs === 'function') {
    requirejs['config']({
      'baseUrl': '.',
      'paths': {
        '@detox/base-x': 'node_modules/@detox/base-x/index',
        '@detox/chat': 'node_modules/@detox/chat/src/index',
        '@detox/core': 'node_modules/@detox/core/src/index',
        '@detox/crypto': 'node_modules/@detox/crypto/src/index',
        '@detox/dht': 'node_modules/@detox/dht/src/index',
        '@detox/routing': 'node_modules/@detox/routing/src/index',
        '@detox/simple-peer': 'node_modules/@detox/simple-peer/simplepeer.min',
        '@detox/transport': 'node_modules/@detox/transport/src/index',
        '@detox/utils': 'node_modules/@detox/utils/src/index',
        'array-map-set': 'node_modules/array-map-set/src/index',
        'async-eventer': 'node_modules/async-eventer/src/index',
        'es-dht': 'node_modules/es-dht/src/index',
        'autosize': 'node_modules/autosize/dist/autosize',
        'fixed-size-multiplexer': 'node_modules/fixed-size-multiplexer/src/index',
        'k-bucket-sync': 'node_modules/k-bucket-sync/src/index',
        'merkle-tree-binary': 'node_modules/merkle-tree-binary/src/index',
        'hotkeys-js': 'node_modules/hotkeys-js/dist/hotkeys',
        'marked': 'node_modules/marked/marked.min',
        'pako': 'node_modules/pako/dist/pako',
        'random-bytes-numbers': 'node_modules/random-bytes-numbers/src/index',
        'ronion': 'node_modules/ronion/src/index',
        'swipe-listener': 'node_modules/swipe-listener/dist/swipe-listener'
      },
      'packages': [
        {
          'name': 'aez.wasm',
          'location': 'node_modules/aez.wasm',
          'main': 'src/index'
        }, {
          'name': 'blake2.wasm',
          'location': 'node_modules/blake2.wasm',
          'main': 'src/index'
        }, {
          'name': 'ed25519-to-x25519.wasm',
          'location': 'node_modules/ed25519-to-x25519.wasm',
          'main': 'src/index'
        }, {
          'name': 'noise-c.wasm',
          'location': 'node_modules/noise-c.wasm',
          'main': 'src/index'
        }, {
          'name': 'supercop.wasm',
          'location': 'node_modules/supercop.wasm',
          'main': 'src/index'
        }
      ]
    });
  } else {
    /**
     * Simple RequireJS-like implementation that replaces alameda and should be enough for bundled modules
     */
    defined_modules = {};
    current_module = {
      exports: null
    };
    wait_for = {};
    /**
     * @param {string} name
     * @param {string} base_name
     *
     * @return {*}
     */
    get_defined_module = function(name, base_name){
      if (name === 'exports') {
        return {};
      } else if (name === 'module') {
        return current_module;
      } else {
        if (name.startsWith('./')) {
          name = base_name.split('/').slice(0, -1).join('/') + '/' + name.substr(2);
        }
        return defined_modules[name];
      }
    };
    /**
     * @param {!Array<string>}	dependencies
     * @param {string}			base_name
     * @param {!Function}		fail_callback
     *
     * @return {Array}
     */
    load_dependencies = function(dependencies, base_name, fail_callback){
      var loaded_dependencies;
      loaded_dependencies = [];
      if (dependencies.every(function(dependency){
        var loaded_dependency;
        loaded_dependency = get_defined_module(dependency, base_name);
        if (!loaded_dependency) {
          fail_callback(dependency);
          return false;
        }
        loaded_dependencies.push(loaded_dependency);
        return true;
      })) {
        return loaded_dependencies;
      } else {
        return null;
      }
    };
    /**
     * @param {string}		name
     * @param {!Function}	callback
     */
    add_wait_for = function(name, callback){
      (wait_for[name] || (wait_for[name] = [])).push(callback);
    };
    /**
     * @param {!Array<string>}	dependencies
     * @param {!Function}		callback
     *
     * @return {!Promise}
     */
    window['require'] = window['requirejs'] = function(dependencies, callback){
      return new Promise(function(resolve){
        var loaded_dependencies;
        loaded_dependencies = load_dependencies(dependencies, '', function(dependency){
          add_wait_for(dependency, function(){
            return window['require'](dependencies, function(){
              var loaded_dependencies, res$, i$, to$;
              res$ = [];
              for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
                res$.push(arguments[i$]);
              }
              loaded_dependencies = res$;
              if (callback) {
                callback.apply(null, loaded_dependencies);
              }
              resolve(loaded_dependencies);
            });
          });
        });
        if (loaded_dependencies) {
          if (callback) {
            callback.apply(null, loaded_dependencies);
          }
          resolve(loaded_dependencies);
        }
      });
    };
    /**
     * @param {string}			name
     * @param {!Array<string>}	dependencies
     * @param {!Function}		wrapper
     */
    window['define'] = function(name, dependencies, wrapper){
      var loaded_dependencies;
      if (!wrapper) {
        wrapper = dependencies;
        dependencies = [];
      }
      loaded_dependencies = load_dependencies(dependencies, name, function(dependency){
        add_wait_for(dependency, function(){
          return define(name, dependencies, wrapper);
        });
      });
      if (loaded_dependencies) {
        defined_modules[name] = wrapper.apply(null, loaded_dependencies) || current_module.exports;
        if (wait_for[name]) {
          wait_for[name].forEach(function(resolve){
            resolve();
          });
          delete wait_for[name];
        }
      }
    };
    define['amd'] = {};
  }
}).call(this);
